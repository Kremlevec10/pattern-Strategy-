#Практика в построении кода по паттерну Strategy

### Этап первый 
1. Создан пакет **sorted**
2. Создан пакет **serch**
3. Создан пакет **user**

### Этап второй
В пакете **sorted**
1.  Создан интерфейс **TypeSorted** 
	* объявлен метод ***sorted*** котрый принимает на 
	вход типизированный массив типа **Number** и его детей
* Создан класс **BubbleSort** который **implements** от **TypeSorted**
где реализованна пузырьковая сортировка
* Создан класс **ChoiceSort** который **implements** от **TypeSorted**
где реализованна сортировка выбором

### Этап третий
В пакете **serch**
1.  Создан интерфейс **TypeSerch** 
	* объявлен метод ***serchElement*** котрый принимает на 
	вход типизированный массив типа **Number** и его детей , 
	а так же искоммый элемент типа **int**
* Создан класс **NormalSearch** который **implements** от **TypeSerch**
где реализован обычный поиск элемента простым совпадением с искомым
* Создан класс **BinarySearch** который **implements** от **TypeSerch**
где реализован бинарный поиск элемента

### Этап четверты
В пакете **user**
1.  Создан интерфейс **InterfaceUser** 
	- объявлен метод ***sorted*** котрый принимает на 
	вход типизированный массив типа **Number** и его детей
	* - объявлен метод ***serchElement*** котрый принимает на 
	вход типизированный массив типа **Number** и его детей , 
	а так же искоммый элемент типа **int** 
	* - объявлен метод **printArray**
	
* Создан абстрактный класс **AbstractUser** который **implements** от **InterfaceUser**
где переопределен метод **printArray** и добавленны поля 
	- **TypeSerch typeSerch**
	* - **TypeSorted typeSorted** 
	* - **U[] u**

* Создан класс **RealUser** который **extends** от **AbstractUser**
где 
	- в конструкторе при создании объекта передаются тип Сортировки и тип Поиска
	* - переопределен метод **sorted** в котором сортируется по переданному типу сортировки
	* - переопределен метод **serchElement** в котором ищется элемент по переданному типу поиска
	
 
